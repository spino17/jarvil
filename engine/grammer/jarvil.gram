# This is full specification of jarvil grammer. The style is PEG type where
# |    ->  ordered choice
# []   ->  optional
# +    ->  at least one occurence
# ()   ->  empty string
# This grammer is by no means exhaustive for all programming constructs generally found in production grade languages. However
# it surely contains enough so that anyone who wishes to learn language grammer can benefit from it.


code: block ENDMARKER

# python style of block
block: NEWLINE (INDENT stmt)*

atom: id ['(' params ')'] atom_factor
atom_factor:
    | ('[' C ']' | '.' id ['(' params ')']) atom_factor
    | ()
C:
    | expr
    | bexpr
    | literal
    | atom

type:
    | TYPE
    | id

stmt: 
    | compound_stmt
    | simple_stmt NEWLINE

simple_stmt:
    | decls
    | assign
    | id '(' params ')'
    | # calling a function, break, continue, return

r_assign:
    | expr
    | bexpr
    | literal
    | atom

params:
    | r_asssign ',' params
    | r_assign

decls:
    | decl ',' decls
    | decl

decl:
    | l_decl ['=' r_assign]

l_decl:
    | type id

assign:
    | atom '=' r_assign

compound_stmt:
    | type_decl_stmt
    | function_stmt
    | if_stmt
    | for_stmt
    | while_stmt

type_decl_stmt:
    | 'type' id ':' struct_block
    | 'type' id ':' '(' optparams ')' ['->' id] NEWLINE

struct_block:
    | (INDENT l_decl NEWLINE)*

function_stmt: 'def' id '(' optparams ')' ['->' id] ':' block

optparams:
    | param ',' optparams
    | param

param: type id

if_stmt:
    | 'if' bexpr ':' block elif_stmt
    | 'if' bexpr ':' block [else_block]

elif_stmt:
    | 'elif' bexpr ':' block elif_stmt
    | 'elif' bexpr ':' block [else_block]

else_block:
    | 'else' ':' block

while_stmt: 'while' bexpr ':' block

expr: 
    | term additive
    | term

additive:
    | '+' expr
    | '-' expr
    | ()

term: 
    | factor multitive
    | factor

multitive:
    | '*' term
    | '/' term

factor:
    | '(' expr ')'
    | '+' factor
    | '-' factor
    | atom
    | int
    | float

comp_op:
    | '=='
    | '>='
    | '>'
    | '<='
    | '<'

bexpr: 
    | bterm oritive

oritive: 
    | 'or' bexpr
    | ()

bterm: bfactor anditive

anditive: 
    | 'and' bterm
    | ()

bfactor:
    | 'not' bfactor
    | expr comp_op expr
    | '(' bexpr ')'
    | atom
    | 'True'
    | 'False'

