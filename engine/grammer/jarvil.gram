# This is full specification of jarvil grammer. The style is PEG type where
# |    ->  ordered choice
# []   ->  optional
# +    ->  at least one occurence
# ()   ->  empty string
# This grammer is by no means exhaustive for all programming constructs generally found in production grade languages. However
# it surely contains enough so that anyone who wishes to learn language grammer can benefit from it.


# TODO - there are many places in grammer where there should be atom instead of id for example left side of assignment can be
# an identifier or something like id[(id | int)] (array indexing)


code: stmts

# python style of block
block: NEWLINE (INDENT stmt)+

stmts: stmt+
stmt: 
    | compound_stmt
    | simple_stmt NEWLINE

simple_stmt:
    | decl
    | assign
    | # calling a function

compound_stmt:
    | function_def
    | if_stmt
    | for_stmt
    | while_stmt

type:
    | TYPE  # type token for in-built types
    | id  # identifier for user-defined types - semantic check required here!



r_assign:
    | expr
    | bexpr
    | literal
    | id

l_decl:
    | type id

decl:
    | l_decl ['=' r_assign]
    | struct id ':' struct_block

struct_block:
    | (INDENT l_decl NEWLINE)*

assign: id '=' r_assign  # change this to => atom '=' r_assign

expr: 
    | term additive
    | term

additive:
    | '+' expr
    | '-' expr
    | ()

term: 
    | factor multitive
    | factor

multitive:
    | '*' term
    | '/' term

factor:
    | '(' expr ')'
    | id  # check the type of identifier for valid '+', '-', '*', '/' operations
    | int
    | float

if_stmt:
    | 'if' bexpr ':' block elif_stmt
    | 'if' bexpr ':' block [else_block]
elif_stmt:
    | 'elif' bexpr ':' block elif_stmt
    | 'elif' bexpr ':' block [else_block]
else_block:
    | 'else' ':' block

while_stmt: 'while' bexpr ':' block

comp_op:
    | ==
    | >=
    | >
    | <=
    | <

bexpr: 
    | bterm oritive
oritive: 
    | 'or' bexpr
    | ()
bterm: bfactor anditive
anditive: 
    | 'and' bterm
    | ()
bfactor:
    | 'not' bfactor
    | expr comp_op expr
    | '(' bexpr ')'
    | id  # check the type of identifier is 'bool'
    | 'True'
    | 'False'

function_def: 'def' id '(' optparams ')' ['->' id] ':' block
optparams:
    | param ',' optparams
    | param
param: type id  # type id

